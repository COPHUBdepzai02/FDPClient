/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.client.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.client.chat
import net.ccbluex.liquidbounce.utils.timing.TickTimer
import net.minecraft.network.play.client.C14PacketTabComplete
import net.minecraft.network.play.server.S3APacketTabComplete
import net.minecraft.network.play.server.S3FPacketCustomPayload
import java.util.Comparator
import java.util.TreeSet

object Plugins : Module("Plugins", Category.EXPLOIT, subjective = true, gameDetecting = false) {

    private val tickTimer = TickTimer()
    private var awaiting = false
    private var hintedFromPayload = false

    private val foundPlugins = TreeSet<String>(String.CASE_INSENSITIVE_ORDER)
    private val payloadChannels = TreeSet<String>(Comparator.naturalOrder())
    private val inferredPlugins = TreeSet<String>(String.CASE_INSENSITIVE_ORDER)

    override fun onEnable() {
        if (mc.thePlayer == null) return

        foundPlugins.clear()
        payloadChannels.clear()
        inferredPlugins.clear()
        hintedFromPayload = false

        awaiting = true
        tickTimer.reset()

        sendPacket(C14PacketTabComplete("/"))
    }

    override fun onDisable() {
        awaiting = false
        tickTimer.reset()
    }

    val onUpdate = handler<UpdateEvent> {
        if (!awaiting) return@handler

        tickTimer.update()
        if (tickTimer.hasTimePassed(20)) {
            printResults()
            state = false
            awaiting = false
            tickTimer.reset()
        }
    }

    val onPacket = handler<PacketEvent> { event ->
        if (event.packet is S3APacketTabComplete) {
            val s3 = event.packet
            val commands = s3.func_149630_c()

            for (raw in commands) {
                val parts = raw.split(":")
                if (parts.size > 1) {
                    val pluginName = parts[0].replace("/", "").trim()
                    if (pluginName.isNotEmpty()) {
                        foundPlugins += pluginName
                    }
                }
            }
        }

        if (event.packet is S3FPacketCustomPayload) {
            val p = event.packet
            val channel: String = try {
                p.channelName
            } catch (_: Throwable) {
                try {
                    val m = p.javaClass.getMethod("func_149169_c")
                    m.isAccessible = true
                    (m.invoke(p) as? String) ?: return@handler
                } catch (_: Throwable) { return@handler }
            }

            if (channel.startsWith("MC|") || channel.equals("REGISTER", true) || channel.equals("UNREGISTER", true))
                return@handler

            payloadChannels += channel

            inferPluginFromChannel(channel)?.let { inferred ->
                if (!foundPlugins.contains(inferred)) inferredPlugins += inferred
            }

            if (!hintedFromPayload) {
                hintedFromPayload = true
                chat("§6payload channels: ${payloadChannels.joinToString(", ")}")
            }
        }
    }

    private fun printResults() {
        if (foundPlugins.isNotEmpty()) {
            chat(
                "§aPlugins §7(§8${foundPlugins.size}§7): §c" +
                        foundPlugins.joinToString("§7, §c")
            )
            printWrapped("§2 Plugins (${foundPlugins.size}): ", foundPlugins.joinToString(", "))
        } else {
            chat("§cNo plugins found.")
        }

        val onlyGuesses = inferredPlugins.filter { guess -> !foundPlugins.contains(guess) }
        if (onlyGuesses.isNotEmpty()) {
            chat("§eGuesses from payload §7(§8${onlyGuesses.size}§7): §6" + onlyGuesses.joinToString("§7, §6"))
            printWrapped("§2 Guesses (${onlyGuesses.size}): ", onlyGuesses.joinToString(", "))
        }

        if (payloadChannels.isNotEmpty()) {
            printWrapped("§6payload channels (${payloadChannels.size}): ", payloadChannels.joinToString(", "))
        }

        if (foundPlugins.isEmpty() && inferredPlugins.isEmpty() && payloadChannels.isEmpty()) {
            chat("§cPlugins check timed out...")
        }
    }

    private fun printWrapped(header: String, body: String, max: Int = 300) {
        if (body.isEmpty()) return
        var i = 0
        var first = true
        while (i < body.length) {
            val end = (i + max).coerceAtMost(body.length)
            val chunk = body.substring(i, end)
            chat(if (first) header + chunk else "§2[PL] $chunk")
            first = false
            i = end
        }
    }

    private fun inferPluginFromChannel(channelRaw: String): String? {
        val channel = channelRaw.trim()

        val lower = channel.lowercase()
        if (lower == "bungeecord" || lower == "fml" || lower == "fml|hs" || lower == "fml|mp")
            return null

        val splitters = charArrayOf(':', '|')
        val base = channel.split(*splitters, limit = 2).firstOrNull()?.trim().orEmpty()

        val candidate = base.replace(Regex("[^A-Za-z0-9-_]"), "")
        if (candidate.length < 3) return null

        if (candidate.equals("minecraft", true) || candidate.equals("brand", true)) return null

        return candidate
    }
}