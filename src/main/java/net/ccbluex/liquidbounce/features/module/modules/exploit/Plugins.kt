/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.event.GameTickEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.client.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.client.chat
import net.ccbluex.liquidbounce.file.FileManager
import net.minecraft.network.play.client.C14PacketTabComplete
import net.minecraft.network.play.server.S3APacketTabComplete
import net.minecraft.network.play.server.S3FPacketCustomPayload
import java.io.File
import java.text.SimpleDateFormat
import java.util.Comparator
import java.util.Date
import java.util.TreeSet

object Plugins : Module("Plugins", Category.EXPLOIT, subjective = true, gameDetecting = false) {

    private val saveLog by boolean("SaveLog", false)
    private val autoRescan by boolean("AutoRescan", false)
    private val debug by boolean("Debug", false)
    private val showSuspicious by boolean("ShowSuspicious", true)

    private val scanIntervalTicks by int("ScanIntervalTicks", 200, 20..6000)
    private val tabTimeoutTicks by int("TabTimeoutTicks", 100, 20..2000)

    private val KNOWN_AC = setOf(
        "nocheatplus", "grimac", "aac", "intave", "horizon", "vulcan",
        "spartan", "kauri", "anticheatreloaded", "matrix", "themis", "negativity"
    )

    private val foundPlugins = TreeSet(String.CASE_INSENSITIVE_ORDER)
    private val payloadChannels = TreeSet<String>(Comparator.naturalOrder())
    private val inferredPlugins = TreeSet(String.CASE_INSENSITIVE_ORDER)

    private var lastPrintedPlugins: Set<String> = emptySet()
    private var lastPrintedGuesses: Set<String> = emptySet()
    private var lastPrintedChannels: Set<String> = emptySet()
    private var lastPrintedSuspicious: Set<String> = emptySet()

    private var scanTicks = 0
    private var awaitingTabComplete = false
    private var tabAwaitTicks = 0
    private var hintedFromPayload = false

    private val COLOR_CODE = Regex("§.")
    private val NON_ALNUM = Regex("[^A-Za-z0-9-_]")

    private val channelGetter by lazy {
        try { S3FPacketCustomPayload::class.java.getMethod("func_149169_c").apply { isAccessible = true } }
        catch (_: Throwable) { null }
    }

    override fun onEnable() {
        if (mc.thePlayer == null) return
        resetCollectionsAndTimers()
        if (debug) chat("§7[Plugins] §fStarting scan...")
        requestTabComplete(force = true)
    }

    override fun onDisable() {
        printResultsAndMaybeLog(force = true)
        resetAwait()
        if (debug) chat("§7[Plugins] §fStopped.")
    }

    val onWorld = handler<WorldEvent> {
        if (debug) chat("§7[Plugins] §fWorld/Server changed; resetting state.")
        resetAll()
    }

    val onTick = handler<GameTickEvent> {
        if (autoRescan) {
            scanTicks++
            if (scanTicks >= scanIntervalTicks) {
                requestTabComplete()
                scanTicks = 0
            }
        }
        if (awaitingTabComplete) {
            tabAwaitTicks++
            if (tabAwaitTicks >= tabTimeoutTicks) {
                awaitingTabComplete = false
                if (debug) chat("§7[Plugins] §6Tab-Complete timed out; will retry on next cycle.")
            }
        }
    }

    val onPacket = handler<PacketEvent> { event ->
        when (val pkt = event.packet) {
            is S3APacketTabComplete -> {
                if (!awaitingTabComplete) return@handler
                awaitingTabComplete = false
                val commands = readTabMatchesCompat(pkt) ?: emptyArray()
                if (commands.isEmpty()) {
                    if (debug) chat("§7[Plugins] §6Tab-Complete returned 0 matches.")
                    return@handler
                }
                val before = TreeSet(foundPlugins.comparator()).apply { addAll(foundPlugins) }
                for (raw in commands) {
                    val idx = raw.indexOf(':')
                    if (idx <= 0) continue
                    val pluginName = raw.substring(0, idx).replace("/", "").trim()
                    if (pluginName.isNotEmpty()) foundPlugins += pluginName
                }
                if (foundPlugins != before) {
                    printResultsAndMaybeLog()
                } else if (debug) {
                    chat("§7[Plugins] §fNo new plugins since last scan.")
                }
            }
            is S3FPacketCustomPayload -> {
                val channel = extractChannel(pkt) ?: return@handler
                if (shouldIgnoreChannel(channel)) return@handler
                val added = payloadChannels.add(channel)
                inferPluginFromChannel(channel)?.let { guess ->
                    if (!foundPlugins.contains(guess)) inferredPlugins += guess
                }
                if (added && !hintedFromPayload && debug) {
                    hintedFromPayload = true
                    chat("§7[Plugins] §6Payload channels: §e${payloadChannels.joinToString(", ")}")
                }
                printResultsAndMaybeLog()
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    private fun readTabMatchesCompat(packet: S3APacketTabComplete): Array<String>? {
        return try {
            val m = packet.javaClass.getMethod("func_149630_c")
            m.isAccessible = true
            m.invoke(packet) as? Array<String>
        } catch (_: Throwable) {
            try {
                val m2 = packet.javaClass.getMethod("getMatches")
                m2.isAccessible = true
                m2.invoke(packet) as? Array<String>
            } catch (_: Throwable) { null }
        }
    }

    private fun requestTabComplete(force: Boolean = false) {
        if (awaitingTabComplete && !force) return
        runCatching {
            awaitingTabComplete = true
            tabAwaitTicks = 0
            sendPacket(C14PacketTabComplete("/"))
            if (debug) chat("§7[Plugins] §fRequesting command suggestions...")
        }.onFailure {
            awaitingTabComplete = false
            if (debug) chat("§7[Plugins] §cFailed to send Tab-Complete: ${it.message}")
        }
    }

    private fun extractChannel(p: S3FPacketCustomPayload): String? =
        try { p.channelName } catch (_: Throwable) {
            try { channelGetter?.invoke(p) as? String } catch (_: Throwable) { null }
        }

    private fun shouldIgnoreChannel(chRaw: String): Boolean {
        val ch = chRaw.trim()
        if (ch.startsWith("MC|")) return true
        if (ch.equals("REGISTER", true) || ch.equals("UNREGISTER", true)) return true
        return when (ch.lowercase()) {
            "bungeecord", "fml", "fml|hs", "fml|mp", "brand", "minecraft" -> true
            else -> false
        }
    }

    private fun inferPluginFromChannel(channelRaw: String): String? {
        val splitters = charArrayOf(':', '|')
        val base = channelRaw.trim().split(*splitters, limit = 2).firstOrNull()?.trim().orEmpty()
        val candidate = base.replace(NON_ALNUM, "")
        if (candidate.length < 3) return null
        if (candidate.equals("minecraft", true) || candidate.equals("brand", true)) return null
        return candidate
    }

    private fun computeSuspicious(): Set<String> {
        val s = TreeSet(String.CASE_INSENSITIVE_ORDER)
        for (p in foundPlugins) if (KNOWN_AC.contains(p.lowercase())) s += p
        for (g in inferredPlugins) if (KNOWN_AC.contains(g.lowercase())) s += g
        return s
    }

    private fun visibleLength(s: String) = s.replace(COLOR_CODE, "").length

    private fun printResultsAndMaybeLog(force: Boolean = false) {
        val onlyGuesses = inferredPlugins.filter { !foundPlugins.contains(it) }.toSet()
        val suspicious = if (showSuspicious) computeSuspicious() else emptySet()

        val shouldPrintPlugins = force || (foundPlugins != lastPrintedPlugins)
        val shouldPrintGuesses = force || (onlyGuesses != lastPrintedGuesses)
        val shouldPrintChannels = force || (payloadChannels != lastPrintedChannels)
        val shouldPrintSuspicious = force || (suspicious != lastPrintedSuspicious)

        if (shouldPrintPlugins) {
            if (foundPlugins.isNotEmpty()) {
                printColoredListWithHeader(
                    header = "§aPlugins §7(§8${foundPlugins.size}§7): ",
                    items = foundPlugins,
                    itemColor = "§c",
                    sepColor = "§7"
                )
            } else {
                chat("§7[Plugins] §cNo plugins found.")
            }
            lastPrintedPlugins = HashSet(foundPlugins)
        }

        if (shouldPrintGuesses) {
            if (onlyGuesses.isNotEmpty()) {
                printColoredListWithHeader(
                    header = "§eGuesses §7(§8${onlyGuesses.size}§7): ",
                    items = onlyGuesses,
                    itemColor = "§6",
                    sepColor = "§7"
                )
            }
            lastPrintedGuesses = HashSet(onlyGuesses)
        }

        if (shouldPrintChannels) {
            if (payloadChannels.isNotEmpty()) {
                printColoredListWithHeader(
                    header = "§6Payload channels §7(§8${payloadChannels.size}§7): ",
                    items = payloadChannels,
                    itemColor = "§6",
                    sepColor = "§7"
                )
            }
            lastPrintedChannels = HashSet(payloadChannels)
        }

        if (shouldPrintSuspicious) {
            if (suspicious.isNotEmpty()) {
                printColoredListWithHeader(
                    header = "§eSuspicious §7(§8${suspicious.size}§7): ",
                    items = suspicious,
                    itemColor = "§c",
                    sepColor = "§7"
                )
            }
            lastPrintedSuspicious = HashSet(suspicious)
        }

        if (saveLog && (shouldPrintPlugins || shouldPrintGuesses || shouldPrintChannels || shouldPrintSuspicious)) {
            writeScanLog()
        }
    }

    private fun printColoredListWithHeader(
        header: String,
        items: Collection<String>,
        itemColor: String,
        sepColor: String,
        maxLineChars: Int = 230
    ) {
        if (items.isEmpty()) {
            chat(header.trim())
            return
        }
        var firstLine = true
        var line = StringBuilder()
        var firstItem = true

        fun flush() {
            if (line.isEmpty()) return
            if (firstLine) chat(header + line.toString()) else chat(line.toString())
            line = StringBuilder()
            firstLine = false
        }

        for (name in items) {
            val seg = (if (firstItem) "" else "$sepColor, ") + itemColor + name
            val projected = (if (firstLine) header else "") + line.toString() + seg
            if (visibleLength(projected) > maxLineChars) flush()
            line.append(seg)
            firstItem = false
        }
        flush()
    }

    private fun writeScanLog() {
        val server = currentServerName()
        val dir: File = FileManager.pluginsDir
        if (!dir.exists()) dir.mkdirs()
        val file = File(dir, "plugins_scan-$server.txt")
        val fmt = SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
        val now = fmt.format(Date())
        val onlyGuesses = inferredPlugins.filter { !foundPlugins.contains(it) }
        val suspicious = if (showSuspicious) computeSuspicious() else emptySet()
        val sb = StringBuilder()
        sb.appendLine("=== FDP Plugins Scan ===")
        sb.appendLine("Server : $server")
        sb.appendLine("When   : $now")
        sb.appendLine()
        if (foundPlugins.isNotEmpty()) {
            sb.appendLine("Plugins (${foundPlugins.size}):")
            sb.appendLine(foundPlugins.joinToString(", "))
            sb.appendLine()
        } else {
            sb.appendLine("Plugins (0): none")
            sb.appendLine()
        }
        if (onlyGuesses.isNotEmpty()) {
            sb.appendLine("Guesses (${onlyGuesses.size}):")
            sb.appendLine(onlyGuesses.joinToString(", "))
            sb.appendLine()
        } else {
            sb.appendLine("Guesses (0): none")
            sb.appendLine()
        }
        if (payloadChannels.isNotEmpty()) {
            sb.appendLine("Payload channels (${payloadChannels.size}):")
            sb.appendLine(payloadChannels.joinToString(", "))
            sb.appendLine()
        } else {
            sb.appendLine("Payload channels (0): none")
            sb.appendLine()
        }
        if (suspicious.isNotEmpty()) {
            sb.appendLine("Suspicious (${suspicious.size}):")
            sb.appendLine(suspicious.joinToString(", "))
            sb.appendLine()
        } else {
            sb.appendLine("Suspicious (0): none")
            sb.appendLine()
        }
        sb.appendLine("================================")
        sb.appendLine()
        try {
            file.appendText(sb.toString(), Charsets.UTF_8)
            chat("§7[log] saved to §f${file.path}")
        } catch (t: Throwable) {
            chat("§7[log] §cfailed to save: ${t.message}")
        }
    }

    private fun currentServerName(): String {
        return try {
            val data = mc.currentServerData
            val raw = data?.serverIP ?: "singleplayer"
            raw.replace(Regex("[^A-Za-z0-9._-]"), "_")
        } catch (_: Throwable) { "unknown" }
    }

    private fun resetCollectionsAndTimers() {
        foundPlugins.clear()
        payloadChannels.clear()
        inferredPlugins.clear()
        lastPrintedPlugins = emptySet()
        lastPrintedGuesses = emptySet()
        lastPrintedChannels = emptySet()
        lastPrintedSuspicious = emptySet()
        hintedFromPayload = false
        scanTicks = 0
        resetAwait()
    }

    private fun resetAwait() {
        awaitingTabComplete = false
        tabAwaitTicks = 0
    }

    private fun resetAll() {
        resetCollectionsAndTimers()
    }
}